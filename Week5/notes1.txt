1. 注意在做binary search的时候，再计算mid时，要避免Overflow的情况出现。注意代码应该怎么写。 mid = start + ((end-start) >> 1)

2. 选择排序selection sort

	/** Sort an array of ints using Selection Sort */
	public static void selectionSort( int[] vals )   {
		
		int minI;
		for ( int i=0; i < vals.length-1 ; i++ ) {
			minI = i;
			
			for ( int j=i; j < vals.length; j++ ) {
				if ( vals[j] < vals[minI] ) {
					minI = j ;
				}
			}
			
			swap(vals, minI, i);
		}
		
	}

3. 插入排序 insertion sort

	public static void mysterySort( int[] vals )    {
		  int currInd;
		  for ( int pos=1; pos < vals.length ; pos++ ) {
		    currInd = pos ;
		    while ( currInd > 0 && 
			    vals[currInd] < vals[currInd-1] ) {
		      swap(vals, currInd, currInd-1);
		      currInd = currInd - 1;
		    }
		  }
		}

4. 注意！！！Java的一些built-in的排序算法，比如Arrays.sort()和Collections.sort(), 内部的实现都是merge sort.
merge sort是一种稳定排序算法，而quick sort不是稳定排序算法。

5. 对于一般的customized的类来说，他们的对象是不能够直接用Arrays.sort()或者Collections.sort()的！！！！有两种方法，可以解决。

方法1：
	对这些用户自定义的类，让他们implements Comparable<Type>接口，然后override如下方法
	public int compareTo(Type o1){

	}
	比如对于Integer, 我们可以在eclipse里看到Integer类是实现了Comparable接口的！！！
	
方法2：



